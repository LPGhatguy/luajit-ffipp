# LuaJIT FFI++
![shield_license]
![shield_release_version]
![shield_prerelease_version]
![shield_dev_version]

FFI++ is a C++ FFI for LuaJIT 2.0+.

## Supported Platforms/Compilers:
FFI++ supports any compiler that can generate Itanium C++ ABI-compliant symbols, as well as MSVC-style symbols on Windows.

### Windows:
- Visual Studio 2005+ (MSVC-style symbols)
- Clang (Itanium and MSVC-style symbols)
- GCC 3.0+ (Itanium-style symbols)

### Linux, Mac OS X:
- GCC 3.0+ (Itanium-style symbols)
- Clang (Itanium-style symbols)

## Creating a Binding
***The binding generator presently only works with MSVC-style symbols on Windows.***

### What You Need
There are two platform sets bindings should support to cover most compilers. MSVC-style symbols can be generated by Visual Studio (Windows-only) or Clang (everything). Itanium-style symbols can be generated by pretty much everything else, notably Clang (everything) and GCC 3.0+ (everything).

This means that if you have a clang installation, you can generate bindings for all possible cases. Otherwise, you'll need Visual Studio and one other compiler.

On Windows, you'll need `dumpbin.exe`, which you can get from Visual Studio.

On Linux, you'll need `nm`, which comes with GCC on Linux.

For MSVC-style symbol binding generation with the included binding generator, you'll also need a copy of `undname.exe`, which you can get from Visual Studio (Express or otherwise) or from WINE, if you're on another platform.

For Itanium-style symbol binding generation, you'll need `nm`, which comes with GCC on Linux and GNU BinUtils on Windows, which can come from MinGW, Cygwin, or elsewhere.

### Actually Creating the Binding
For every symbol style you need to support, you'll need a copy of the library compiled with that symbol style. For this example, I've compiled my example file, `HelloWorld.cpp` into two assemblies, `HelloWorld-msvc.dll` and `HelloWorld-itanium.dll`. I'm planning to rename them to `HelloWorld.dll` when I distribute my application, removing the compiler suffix.

To produce a binding with these inputs and the desired assembly name, I would execute a command like this:

```bash
luajit ljgenbinding.lua --output=HelloWorld.ffipp HelloWorld-msvc.dll
```

This produces a file named `HelloWorld.fipp` that can be loaded by FFI++ at runtime. It will automatically load an assembly named 'HelloWorld' at runtime.

## Using a Binding
See the `examples` directory for directions on using a binding.

## Notes
- Some compilers will not export symbols of member functions with inline definitions. If you notice a missing constructor after generating a binding, modifying the code or filling in the missing method in Lua might be necessary.

[shield_license]: https://img.shields.io/badge/license-zlib/libpng-333333.svg?style=flat-square
[shield_release_version]: https://img.shields.io/badge/release-1.2.0-brightgreen.svg?style=flat-square
[shield_prerelease_version]: https://img.shields.io/badge/prerelease-1.3.0--alpha-blue.svg?style=flat-square
[shield_dev_version]: https://img.shields.io/badge/development-1.3.0-orange.svg?style=flat-square